from prettytable import PrettyTable
from datetime import datetime
import json
import os

section_break = "\n\n------------------------------\n\n"

newline = "\n\n"

report_header = """

    +---------------------+
    |    MASAPT REPORT    |
    +---------------------+

This document contains results of all tests that MASAPT
has conducted.

"""


empty_report = report_header + section_break + "This report is empty..."

CRED = '\33[31m'
CGREEN = '\33[32m'
CYELLOW = '\33[33m'
CCYAN = '\33[36m'
CBLUE = '\33[95m'

CBOLD = '\33[1m'

CEND = '\33[0m'

specials = [CRED, CGREEN, CYELLOW, CCYAN, CBLUE, CBOLD, CEND]

sqli_test = '''{
    "target": "localhost/sqlilabs/Less-1/?id=",
    "dbms_type": "MySQL >= 5.0 (MariaDB fork)",
    "databases": {
        "challenges": [
            "JVY2709DPX"
        ],
        "security": [
            "emails",
            "referers",
            "uagents",
            "users"
        ]
    },
    "tables": {
        "JVY2709DPX": [],
        "emails": [
            "| id | email_id               |",
            "| 1  | Dumb@dhakkan.com       |",
            "| 2  | Angel@iloveu.com       |",
            "| 3  | Dummy@dhakkan.local    |",
            "| 4  | secure@dhakkan.local   |"
        ],
        "referers": [],
        "uagents": [],
        "users": [
            "| id | password   | username |",
            "| 1  | Dumb       | Dumb     |",
            "| 2  | I-kill-you | Angelina |",
            "| 3  | p@ssword   | Dummy    |",
            "| 4  | crappy     | secure   |"
        ]
    }
}'''



# Buils table where columns are database names and rows are table names from thoose databases.
def __build_db_and_tables_report(databases: dict):

    db_tables = PrettyTable(databases.keys())

    # Sizes of table lists for each databases.
    table_list_sizes = [len(databases[db]) for db in databases]

    # Getting the biggest list size.
    max_list_size = max(table_list_sizes)

    # If list is not the same site as the biggest list - fill the difference with empty string.
    # This is neccessary for nice console output
    for db in databases.keys():
        if len(databases[db]) < max_list_size:
            max_diff = max_list_size - len(databases[db])
            empty_strings = ["" for i in range(max_diff)]
            databases[db] = databases[db] + empty_strings

    # Append rows of table names to final report table.
    for elems in zip(*databases.values()):
        db_tables.add_row(elems)


    return db_tables

# Builds tables from SQLi report.
def __build_table_samples(tables: dict) -> list:

    # List of PrettyTable tables.
    samples = [] # [PrettyTable, ..., PrettyTable]

    for table in tables.keys():

        table_sample = PrettyTable()

        # If the table if empty just write its title in one column.
        if len(tables[table]) == 0:
            table_sample.field_names = [table]
        else:
            # Set table title to table name from JSON.
            table_sample.title = table

            # First elements is the table header that contains column names.
            table_sample.field_names = list(filter(None, [elem.strip() for elem in tables[table][0].split("|")]))

            # Fill the rest of the table with data.
            for row in tables[table][1:]:

                # Take row, add it to data
                table_sample.add_row(list(filter(None, [elem.strip() for elem in row.split("|")])))

        # Append single table into list with other tables.
        samples.append(table_sample)

    return samples

# Build part of the report from JSON file generated by SQL injection agent.
def __sqli_json_to_report(sqli_results: dict):

    sqli_report = ''''''

    sqli_report += CBOLD + " ~~ This section contains SQL injection exploit report ~~ " + CEND
    sqli_report += section_break
    sqli_report += CRED + "Target: " + CEND + sqli_results["target"] + newline
    sqli_report += CGREEN + "DBMS Type: " + CEND + sqli_results["dbms_type"]

    sqli_report += section_break

    db_names = [i for i in sqli_results["databases"].keys()]
    sqli_report += CYELLOW + "Databases found: " + CEND + str(db_names)

    sqli_report += section_break

    sqli_report +=  CCYAN + "Tables in databases:" + CEND + newline
    db_tables = __build_db_and_tables_report(sqli_results["databases"])
    sqli_report += str(db_tables)

    sqli_report += section_break


    sqli_report += CBLUE + "Table samples:" + CEND + CBOLD + "\n * Tables contain only samples (top 5 rows), not whole tables!" + CEND + newline
    table_samples = __build_table_samples(sqli_results["tables"])

    for table in table_samples:
        sqli_report += str(table) + newline


    return sqli_report

# Removes all special color characters from given text.
def __remove_special_characters(in_text: str) -> str:

    # Shutup about regex.
    for bad in specials:
        in_text = in_text.replace(bad,"")

    return in_text



# Build final report to showcase to the user from multiple sources.
def build_report(*args, **kwargs):

    report = ""

    if "sqli_results" in kwargs:

        # If there is SQLi result passed as parameter - place it into a variable.
        sqli_res_string = kwargs["sqli_results"]

        # Formatting JSON that is recived in a string.
        sqli_res_string = sqli_res_string.replace("'", "\"")
        # Converting string JSON into python dictionary.
        sqli_res = json.loads(sqli_res_string)


        if sqli_res != None:

            report = report_header
            report += section_break

            report += __sqli_json_to_report(sqli_res)

    else:

        report = empty_report

    return report

# Saves strings to txt file.
def save_report_to_txt(report):

    # Remove special characters for conosle coloring and other from final report.
    report = __remove_special_characters(report)

    time = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")

    # Path where 'reports' file is saved on the PC.
    rel_path = os.path.dirname(os.path.realpath(__file__))

    with open(f"{rel_path}/reports/masapt_report_{time}.txt", "w") as txt_file:
        txt_file.write(report)
        txt_file.close()
