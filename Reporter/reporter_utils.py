from prettytable import PrettyTable


section_break = "\n\n------------------------------\n\n"

newline = "\n\n"

report_header = """

    +---------------------+
    |    PENTEST REPORT   |
    +---------------------+

This is the final document that contains results of all tests that MASAPT
has conducted.

"""

CRED = '\33[31m'
CGREEN = '\33[32m'
CYELLOW = '\33[33m'
CCYAN = '\33[36m'
CBLUE = '\33[95m'

CBOLD = '\33[1m'

CEND = '\33[0m'

sqli_test = {
    "target": "localhost/sqlilabs/Less-1/?id=",
    "dbms_type": "MySQL >= 5.0 (MariaDB fork)",
    "databases": {
        "challenges": [
            "JVY2709DPX"
        ],
        "security": [
            "emails",
            "referers",
            "uagents",
            "users"
        ]
    },
    "tables": {
        "JVY2709DPX": [],
        "emails": [
            "| id | email_id               |",
            "| 1  | Dumb@dhakkan.com       |",
            "| 2  | Angel@iloveu.com       |",
            "| 3  | Dummy@dhakkan.local    |",
            "| 4  | secure@dhakkan.local   |"
        ],
        "referers": [],
        "uagents": [],
        "users": [
            "| id | password   | username |",
            "| 1  | Dumb       | Dumb     |",
            "| 2  | I-kill-you | Angelina |",
            "| 3  | p@ssword   | Dummy    |",
            "| 4  | crappy     | secure   |"
        ]
    }
}


# Buils table where columns are database names and rows are table names from thoose databases.
def build_db_and_tables_report(databases: dict):

    db_tables = PrettyTable(databases.keys())

    # Sizes of table lists for each databases.
    table_list_sizes = [len(databases[db]) for db in databases]

    # Getting the biggest list size.
    max_list_size = max(table_list_sizes)

    # If list is not the same site as the biggest list - fill the difference with empty string.
    # This is neccessary for nice console output
    for db in databases.keys():
        if len(databases[db]) < max_list_size:
            max_diff = max_list_size - len(databases[db])
            empty_strings = ["" for i in range(max_diff)]
            databases[db] = databases[db] + empty_strings

    # Append rows of table names to final report table.
    for elems in zip(*databases.values()):
        db_tables.add_row(elems)


    return db_tables


def build_table_samples(tables: dict) -> list:

    # List of PrettyTable tables.
    samples = [] # -> PrettyTable

    for table in tables.keys():

        table_sample = PrettyTable()

        if len(tables[table]) == 0:
            table_sample.field_names = [table]
        else:
            # Set table title to table name from JSON.
            table_sample.title = table

            # First elements is the table header that contains column names.
            names = [elem.strip() for elem in tables[table][0].split("|")]
            table_sample.field_names = names

            # Fill the rest of the table with data.
            for row in tables[table][1:]:
                row = row.split("|")
                table_sample.add_row([elem.strip() for elem in row])

        samples.append(table_sample)

    return samples


# Build part of the report from JSON file generated by SQL injection agent.
def sqli_json_to_report(sqli_results: dict):

    sqli_report = ''''''

    sqli_report += CBOLD + " ~~ This section contains SQL injection exploit report ~~ " + CEND + newline
    sqli_report += CRED + "Target: " + CEND + sqli_results["target"] + newline
    sqli_report += CGREEN + "DBMS Type: " + CEND + sqli_results["dbms_type"]

    sqli_report += section_break

    db_names = [i for i in sqli_results["databases"].keys()]
    sqli_report += CYELLOW + "Databases found: " + CEND + str(db_names)

    sqli_report += section_break

    sqli_report +=  CCYAN + "Tables in databases:" + CEND + newline
    db_tables = build_db_and_tables_report(sqli_results["databases"])
    sqli_report += str(db_tables)

    sqli_report += section_break


    sqli_report += CBLUE + "Table samples:" + CEND + newline
    table_samples = build_table_samples(sqli_results["tables"])

    for table in table_samples:
        sqli_report += str(table) + newline


    return sqli_report



# Build final report to showcase to the user from multiple sources.
def build_report(*args):

    report = report_header
    report += section_break

    for arg in args:

        if isinstance(arg, list):
            pass

        elif isinstance(arg, dict):
            pass




if __name__ == "__main__":
    # build_report({"osoba":"marko"})
    report = sqli_json_to_report(sqli_test)

    print(report)
